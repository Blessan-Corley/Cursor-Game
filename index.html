<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cursor Chase Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        canvas {
            border: 3px solid #ffffff;
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            cursor: none;
        }
        
        .ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            z-index: 10;
        }
        
        .score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .status {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .reverse-warning {
            color: #ff4444;
            font-weight: bold;
            font-size: 16px;
        }
        
        .instructions {
            font-size: 16px;
            opacity: 0.8;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            color: black;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 20;
            display: none;
            border: 2px solid #000;
        }
        
        .game-over h2 {
            margin-top: 0;
            color: #000;
        }
        
        .restart-btn {
            background: #000;
            color: white;
            border: 2px solid #000;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 15px;
        }
        
        .restart-btn:hover {
            background: #333;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="score">Score: <span id="scoreDisplay">0</span></div>
        <div class="status">Speed Level: <span id="speedLevel">1</span></div>
        <div class="status reverse-warning" id="reverseWarning" style="display: none;">CONTROLS REVERSED!</div>
        <div class="instructions" id="instructions">Press SPACE to start playing!</div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <p>The ball caught you!</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>
    
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const speedLevelDisplay = document.getElementById('speedLevel');
        const reverseWarning = document.getElementById('reverseWarning');
        const instructions = document.getElementById('instructions');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        
        // Game state
        let gameState = 'waiting'; // 'waiting', 'playing', 'gameOver'
        let score = 0;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let rawMouseX = canvas.width / 2;
        let rawMouseY = canvas.height / 2;
        let shakeIntensity = 0;
        let isControlsReversed = false;
        let reverseControlsTimer = 0;
        let speedLevel = 1;
        
        // Circle arena
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const arenaRadius = 280;
        
        // Ball (chaser) - with progressive difficulty
        const ball = {
            x: centerX,
            y: centerY - 100,
            radius: 15,
            baseSpeed: 3.5,
            currentSpeed: 3.5,
            color: '#ffffff',
            vx: 0,
            vy: 0
        };
        
        // Game timing
        const starLifetime = 4000; // 4 seconds to collect stars
        const redStarLifetime = 6000; // Red stars last longer
        const reverseControlsDuration = 3000; // 3 seconds of reversed controls
        
        // Stars array
        let stars = [];
        const maxStars = 3;
        const starRadius = 8;
        
        // Mouse tracking with boundary constraint and reverse controls
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            rawMouseX = e.clientX - rect.left;
            rawMouseY = e.clientY - rect.top;
            
            let targetMouseX = rawMouseX;
            let targetMouseY = rawMouseY;
            
            // Apply reverse controls if active
            if (isControlsReversed && gameState === 'playing') {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                targetMouseX = centerX - (rawMouseX - centerX);
                targetMouseY = centerY - (rawMouseY - centerY);
            }
            
            // If game is playing, constrain mouse to circle
            if (gameState === 'playing') {
                const distFromCenter = Math.sqrt((targetMouseX - centerX) ** 2 + (targetMouseY - centerY) ** 2);
                if (distFromCenter > arenaRadius - 10) {
                    const angle = Math.atan2(targetMouseY - centerY, targetMouseX - centerX);
                    targetMouseX = centerX + Math.cos(angle) * (arenaRadius - 10);
                    targetMouseY = centerY + Math.sin(angle) * (arenaRadius - 10);
                }
            }
            
            mouseX = targetMouseX;
            mouseY = targetMouseY;
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'waiting') {
                    startGame();
                }
            }
        });
        
        function startGame() {
            gameState = 'playing';
            score = 0;
            speedLevel = 1;
            stars = [];
            ball.x = centerX;
            ball.y = centerY - 100;
            ball.vx = 0;
            ball.vy = 0;
            ball.currentSpeed = ball.baseSpeed;
            shakeIntensity = 0;
            isControlsReversed = false;
            reverseControlsTimer = 0;
            instructions.style.display = 'none';
            gameOverScreen.style.display = 'none';
            reverseWarning.style.display = 'none';
            spawnStar();
        }
        
        function restartGame() {
            gameState = 'waiting';
            instructions.style.display = 'block';
            instructions.textContent = 'Press SPACE to start playing!';
            gameOverScreen.style.display = 'none';
            scoreDisplay.textContent = '0';
            speedLevelDisplay.textContent = '1';
            reverseWarning.style.display = 'none';
        }
        
        function updateDifficulty() {
            // Increase speed every 75 points
            const newSpeedLevel = Math.floor(score / 75) + 1;
            if (newSpeedLevel !== speedLevel) {
                speedLevel = newSpeedLevel;
                ball.currentSpeed = ball.baseSpeed + (speedLevel - 1) * 0.8;
                speedLevelDisplay.textContent = speedLevel;
            }
        }
        
        function spawnStar() {
            if (stars.length < maxStars) {
                let attempts = 0;
                let validPosition = false;
                let starX, starY;
                
                while (!validPosition && attempts < 50) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * (arenaRadius - starRadius - 30) + starRadius + 30;
                    
                    starX = centerX + Math.cos(angle) * distance;
                    starY = centerY + Math.sin(angle) * distance;
                    
                    const distFromBall = Math.sqrt((starX - ball.x) ** 2 + (starY - ball.y) ** 2);
                    const distFromMouse = Math.sqrt((starX - mouseX) ** 2 + (starY - mouseY) ** 2);
                    
                    if (distFromBall > ball.radius + starRadius + 40 && distFromMouse > starRadius + 40) {
                        validPosition = true;
                    }
                    attempts++;
                }
                
                if (validPosition) {
                    // 15% chance for red star (reverse controls)
                    const isRedStar = Math.random() < 0.15;
                    const lifetime = isRedStar ? redStarLifetime : starLifetime;
                    
                    stars.push({
                        x: starX,
                        y: starY,
                        radius: starRadius,
                        collected: false,
                        isRed: isRedStar,
                        spawnTime: Date.now(),
                        lifetime: lifetime,
                        blinkTimer: 0
                    });
                }
            }
        }
        
        function updateBall() {
            if (gameState !== 'playing') return;
            
            // Calculate direction to mouse for chasing behavior
            const dx = mouseX - ball.x;
            const dy = mouseY - ball.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                // Add chasing force to velocity (stronger with higher speed level)
                const chaseForce = 0.3 + (speedLevel - 1) * 0.05;
                ball.vx += (dx / distance) * chaseForce;
                ball.vy += (dy / distance) * chaseForce;
            }
            
            // Reduced drag for more momentum buildup
            ball.vx *= 0.97; // Was 0.95, now less drag
            ball.vy *= 0.97;
            
            // Limit maximum speed based on current difficulty
            const maxSpeed = ball.currentSpeed;
            const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (currentSpeed > maxSpeed) {
                ball.vx = (ball.vx / currentSpeed) * maxSpeed;
                ball.vy = (ball.vy / currentSpeed) * maxSpeed;
            }
            
            // Update position
            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // Bounce off arena walls with physics (less damping for more momentum)
            const distFromCenter = Math.sqrt((ball.x - centerX) ** 2 + (ball.y - centerY) ** 2);
            if (distFromCenter + ball.radius > arenaRadius) {
                // Calculate collision normal
                const normalX = (ball.x - centerX) / distFromCenter;
                const normalY = (ball.y - centerY) / distFromCenter;
                
                // Reflect velocity vector
                const dotProduct = ball.vx * normalX + ball.vy * normalY;
                ball.vx -= 2 * dotProduct * normalX;
                ball.vy -= 2 * dotProduct * normalY;
                
                // Position ball at boundary
                ball.x = centerX + normalX * (arenaRadius - ball.radius);
                ball.y = centerY + normalY * (arenaRadius - ball.radius);
                
                // Less bounce damping for more momentum buildup
                ball.vx *= 0.9; // Was 0.8, now retains more velocity
                ball.vy *= 0.9;
                
                // Trigger shake effect
                shakeIntensity = 8;
            }
            
            // Reduce shake intensity
            if (shakeIntensity > 0) {
                shakeIntensity *= 0.85;
                if (shakeIntensity < 0.1) shakeIntensity = 0;
            }
        }
        
        function updateGameState() {
            if (gameState !== 'playing') return;
            
            // Update reverse controls timer
            if (isControlsReversed) {
                reverseControlsTimer -= 16; // Assuming 60fps
                if (reverseControlsTimer <= 0) {
                    isControlsReversed = false;
                    reverseWarning.style.display = 'none';
                }
            }
            
            // Update stars (check for expiration and blinking)
            const currentTime = Date.now();
            stars.forEach((star, index) => {
                const age = currentTime - star.spawnTime;
                const timeRemaining = star.lifetime - age;
                
                // Start blinking when 1 second left
                if (timeRemaining < 1000) {
                    star.blinkTimer += 16;
                    star.isBlinking = Math.floor(star.blinkTimer / 200) % 2 === 0;
                }
                
                // Remove expired stars
                if (timeRemaining <= 0) {
                    stars.splice(index, 1);
                }
            });
            
            // Update difficulty
            updateDifficulty();
        }
        
        function checkCollisions() {
            if (gameState !== 'playing') return;
            
            // Check ball-cursor collision
            const distToCursor = Math.sqrt((mouseX - ball.x) ** 2 + (mouseY - ball.y) ** 2);
            if (distToCursor < ball.radius + 8) {
                gameState = 'gameOver';
                finalScoreDisplay.textContent = score;
                gameOverScreen.style.display = 'block';
                return;
            }
            
            // Check star collection
            stars.forEach((star, index) => {
                if (!star.collected) {
                    const distToStar = Math.sqrt((mouseX - star.x) ** 2 + (mouseY - star.y) ** 2);
                    if (distToStar < star.radius + 12) {
                        star.collected = true;
                        
                        if (star.isRed) {
                            // Red star: reverse controls
                            isControlsReversed = true;
                            reverseControlsTimer = reverseControlsDuration;
                            reverseWarning.style.display = 'block';
                            score += 5; // Less points for red stars
                        } else {
                            // Normal star
                            score += 10;
                        }
                        
                        scoreDisplay.textContent = score;
                        stars.splice(index, 1);
                        
                        setTimeout(spawnStar, 800);
                    }
                }
            });
        }
        
        function drawStar(ctx, x, y, radius, points = 5) {
            const outerRadius = radius;
            const innerRadius = radius * 0.4;
            
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const starX = x + Math.cos(angle) * r;
                const starY = y + Math.sin(angle) * r;
                
                if (i === 0) {
                    ctx.moveTo(starX, starY);
                } else {
                    ctx.lineTo(starX, starY);
                }
            }
            ctx.closePath();
        }
        
        function draw() {
            // Apply shake effect
            ctx.save();
            if (shakeIntensity > 0) {
                const shakeX = (Math.random() - 0.5) * shakeIntensity;
                const shakeY = (Math.random() - 0.5) * shakeIntensity;
                ctx.translate(shakeX, shakeY);
            }
            
            // Clear canvas with black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw arena circle
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, arenaRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw arena background (dark gray)
            ctx.fillStyle = '#111111';
            ctx.fill();
            
            // Draw stars
            stars.forEach(star => {
                // Skip drawing if blinking and in "off" phase
                if (star.isBlinking && star.blinkTimer && Math.floor(star.blinkTimer / 200) % 2 === 1) {
                    return;
                }
                
                if (star.isRed) {
                    // Red star
                    ctx.fillStyle = '#ff4444';
                    ctx.strokeStyle = '#ff4444';
                } else {
                    // Normal white star
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                }
                
                ctx.lineWidth = 2;
                drawStar(ctx, star.x, star.y, star.radius);
                ctx.fill();
                ctx.stroke();
            });
            
            // Draw cursor (always visible, black dot with white outline)
            ctx.fillStyle = '#000000';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw ball (white with black outline)
            ctx.fillStyle = ball.color;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        
        function displayDeveloperCredits() {
            console.log('%c┌────────────────────────────────────────────┐', 'color: #667eea; font-size: 14px;');
            console.log('%c│                                            │', 'color: #667eea; font-size: 14px;');
            console.log('%c│        Welcome to Cursor Chase Game!      │', 'color: #764ba2; font-size: 16px; font-weight: bold;');
            console.log('%c│                                            │', 'color: #667eea; font-size: 14px;');
            console.log('%c│    Designed & Developed by Blessan Corley  │', 'color: #f093fb; font-size: 14px; font-weight: 600;');
            console.log('%c│                                            │', 'color: #667eea; font-size: 14px;');
            console.log('%c│    Technologies Used:                      │', 'color: #4facfe; font-size: 13px; font-weight: 500;');
            console.log('%c│    • HTML5 Canvas API                      │', 'color: #43e97b; font-size: 12px;');
            console.log('%c│    • JavaScript ES6+                      │', 'color: #43e97b; font-size: 12px;');
            console.log('%c│    • CSS3 Animations                       │', 'color: #43e97b; font-size: 12px;');
            console.log('%c│    • requestAnimationFrame                 │', 'color: #43e97b; font-size: 12px;');
            console.log('%c│    • 2D Physics & Collision Detection      │', 'color: #43e97b; font-size: 12px;');
            console.log('%c│                                            │', 'color: #667eea; font-size: 14px;');
            console.log('%c│           Enjoy the Game!                  │', 'color: #4facfe; font-size: 14px; font-weight: 600;');
            console.log('%c│                                            │', 'color: #667eea; font-size: 14px;');
            console.log('%c└────────────────────────────────────────────┘', 'color: #667eea; font-size: 14px;');
        }
        
        function gameLoop() {
            updateBall();
            updateGameState();
            checkCollisions();
            draw();
            
            // Spawn stars periodically
            if (gameState === 'playing' && Math.random() < 0.008) {
                spawnStar();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Display developer credits
        displayDeveloperCredits();
        
        // Start the game loop
        gameLoop();
    </script>
</body>
</html>